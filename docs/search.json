[{"path":"/articles/Using-Valve-with-Docker.html","id":"example-dockerfile","dir":"Articles","previous_headings":"","what":"Example Dockerfile","title":"Using Valve with Docker","text":"Dockerfile included valve can found via system.file(\"docker/Dockerfile\", package = \"valve\"). build included plumber API system.file(\"docker/plumber.R\", package = \"valve\"). replciate, copy files directory choosing. Ensure Docker desktop open. build container docker build -t valve:latest .. can run container :","code":"#> FROM rocker/r-ver:4.3.0 #> ENV RENV_CONFIG_REPOS_OVERRIDE https://packagemanager.rstudio.com/cran/latest #>  #> ENV VALVE_HOST 0.0.0.0 #> ENV VALVE_PORT 8000 #>  #> RUN apt-get update -qq && apt-get install -y --no-install-recommends \\ #>   libcurl4-openssl-dev \\ #>   libicu-dev \\ #>   libsodium-dev \\ #>   libssl-dev \\ #>   make \\ #>   zlib1g-dev \\ #>   && apt-get clean #>  #> COPY renv.lock renv.lock #> RUN Rscript -e \"install.packages('renv')\" #> RUN Rscript -e \"renv::restore()\" #> COPY plumber.R /api/plumber.R #>  #> # Install Rust toolchain & add to the path #> RUN apt-get install -y -q \\ #>     build-essential \\ #>     curl #> RUN curl https://sh.rustup.rs -sSf | sh -s -- -y #> ENV PATH=\"/root/.cargo/bin:${PATH}\" #>  #> # Install Valve binary from Github #> RUN cargo install valve-rs --no-default-features #>  #> EXPOSE ${VALVE_PORT} #>  #> # Start Valve app #> ENTRYPOINT valve -f /api/plumber.R -h $VALVE_HOST -p $VALVE_PORT --workers 10 --n-max 10 --check-unused 10 --max-age 300 docker run -p 8000:8000 valve:latest"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Josiah Parry. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Parry J (2023). valve: Redirects Plumbing . https://github.com/JosiahParry/valve, https://josiahparry.r-universe.dev/valve, https://rsgeo.josiahparry.com/.","code":"@Manual{,   title = {valve: Redirects Your Plumbing For You},   author = {Josiah Parry},   year = {2023},   note = {https://github.com/JosiahParry/valve, https://josiahparry.r-universe.dev/valve, https://rsgeo.josiahparry.com/}, }"},{"path":"/index.html","id":"valve","dir":"","previous_headings":"","what":"Redirects Your Plumbing For You","title":"Redirects Your Plumbing For You","text":"Redirects plumbing . valve creates multi-threaded Plumber APIs powered Rust’s tokio axum web frameworks. Plumber connections automatically spawned, pooled, terminated using deadpool. App connections automatically pooled hyper. Valve Rust CLI accompanying R package. Running Valve R session block session. comfortable, recommended install cli can run Valve terminal can call plumber APIs R session.","code":""},{"path":"/index.html","id":"motivation","dir":"","previous_headings":"","what":"Motivation","title":"Redirects Your Plumbing For You","text":"Plumber R package creates RESTful APIs R functions. limited API single R process thus single thread. Multiple queries executed sequence came . Scaling plumber APIs easy. intention valve able make scaling plumber APIs, thus R , easier. can make R better leveraging Rust’s “fearless concurrency.”","code":""},{"path":[]},{"path":"/index.html","id":"cli-instructions","dir":"","previous_headings":"Installation","what":"Cli Instructions","title":"Redirects Your Plumbing For You","text":"install executable run","code":"cargo install valve-rs --no-default-features"},{"path":"/index.html","id":"r-package-instructions","dir":"","previous_headings":"Installation","what":"R package instructions","title":"Redirects Your Plumbing For You","text":"R package simplify use Valve familiar Rust CLI tools. available binary Windows, Linux, MacOSX thanks R-universe. R package built also includes binary executable inst/valve. ever find needing executable system.file(\"valve\", package = \"valve\") point right ! always version executable R package using. can verify binary works machine running . Windows machine include system.file(\"valve.exe\", package = \"valve\") executable.","code":"install.packages(\"valve\", repos = c(\"https://josiahparry.r-universe.dev\", \"https://cloud.r-project.org\")) # get executable path and included api paths valve_executable <- system.file(\"valve\", package = \"valve\") plumber_api_path <- system.file(\"plumber.R\", package = \"valve\")  # check that they exist file.exists(c(valve_executable, plumber_api_path))  # run Valve from the R-package's executable processx::run(   valve_executable,   args = c(\"-f\", plumber_api_path),   echo = TRUE )"},{"path":"/index.html","id":"creating-a-valve-app","dir":"","previous_headings":"","what":"Creating a Valve app","title":"Redirects Your Plumbing For You","text":"run plumber API concurrently using R package, use valve_run(). important argument filepath determines Plumber API executed well specifying host port determine app run. Additional configuration can done n_max, workers, check_unused, max_age argument specify app scale. default, app run host 127.0.0.1 port 3000. Using cli:","code":"library(valve) # get included plumber API path plumber_api_path <- system.file(\"plumber.R\", package = \"valve\")  valve_run(plumber_api_path, n_max = 5) #> Docs hosted at <http://127.0.0.1:3000/__docs__/> valve -f plumber.R -n 5"},{"path":"/index.html","id":"understanding-the-parameters","dir":"","previous_headings":"Creating a Valve app","what":"Understanding the parameters:","title":"Redirects Your Plumbing For You","text":"arguments provide determines Valve scale application requests come . defaults 127.0.0.1. Defines host Axum app plumber API hosted . defaults 3000. Defines port main Axum app listening . defaults plumber.R. path R script defines plumber API. default 3. Determines many workers set Tokio Runtime. workers handle incoming requests return responses. default 3. Refers maximum number background Plumber APIs can spawned whereas workers specifies many main worker threads available handle incoming requests. Generally, number workers equal number plumber APIs since plumber single threaded. default. workers less n_max, ’ll never spawn maximum number APIs. default 10. time interval, seconds, check unused connections. default 300 (five minutes). Specifies long connection can go unused without terminated. connection reaches age terminated next pool check (interval determined check_unused),","code":""},{"path":"/index.html","id":"example-calling-valve-with-multiple-workers","dir":"","previous_headings":"","what":"Example: Calling valve with multiple workers","title":"Redirects Your Plumbing For You","text":"way valve works accepting requests main port (3000 default) distributing requests round robin plumber APIs spawned random ports. Requests captured axum proxied plumber API process. can run example plumber API included Valve background R using code chunk: launch directly terminal via: Valve app running background can begin example. First ’m going define function call /sleep endpoint. function take two parameters: port duration sleep. port used change valve app single plumber API. Using function ’ll create 5 total R sessions make request sleep 2 seconds. First, ’ll ping main valve app distribute requests. first time ran might slow since plumber APIs pool yet. Next, select one available plumber APIs query . Notice performance difference. former worker gets make request approximately amount time. latter wait subsequent step finish next one can occur. ’ve effectively distributed work load.","code":"# create temp file tmp <- tempfile(fileext = \".R\")  # create script lines valve_script <- ' plumber_api_path <- system.file(\"plumber.R\", package = \"valve\") valve::valve_run(plumber_api_path, workers = 5) ' # write to temp writeLines(valve_script, tmp)  # run in the background rstudioapi::jobRunScript(tmp) valve -f $(Rscript -e 'cat(system.file(\"plumber.R\", package = \"valve\"))') sleep <- function(port, secs) {   httr2::request(         paste0(\"127.0.0.1:\", port, \"/sleep?zzz=\", secs)     ) |>      httr2::req_perform() |>      httr2::resp_body_string() } library(furrr) plan(multisession, workers = 5) start <- Sys.time() multi_sleep <- future_map(1:5, ~ sleep(3000, 2)) multi_total <- Sys.time() - start start <- Sys.time() single_sleep <- furrr::future_map(1:5, ~ sleep(53869, 2)) single_total <- Sys.time() - start print(paste0(\"Multiple Plumber APIs: \", round(multi_total, 2))) #> [1] \"Multiple Plumber APIs: 2.63\" print(paste0(\"One Plumber API: \", round(single_total, 2))) #> [1] \"One Plumber API: 10.08\""},{"path":"/index.html","id":"how-valve-works","dir":"","previous_headings":"","what":"How Valve Works","title":"Redirects Your Plumbing For You","text":"architecture, high level, captured diagram.  really three key components : Tokio Runtime, Axum Router, connection Pool.","code":""},{"path":"/index.html","id":"request-handling","dir":"","previous_headings":"How Valve Works","what":"Request handling","title":"Redirects Your Plumbing For You","text":"tokio Runtime allows Valve asynchronous. handles /O, tasks, jazz. also backs Axum. Valve, define asynchronous runtime pre-defined number workers. workers handle incoming requests. request picked , sent Axum Router. router takes incoming requests sends appropriate endpoint. routes defined / /*key. / permanent redirect plumber API documentation. Whereas /*key captures every request. requests special handler , short, act reverse proxy Axum plumber API. handler captures request grabs Plumber connection Pool. Plumber struct contains host port APIs live . request parsed, redirected plumber API. response captured returned response Axum router.","code":""},{"path":"/index.html","id":"connection-pooling","dir":"","previous_headings":"How Valve Works","what":"Connection pooling","title":"Redirects Your Plumbing For You","text":"Valve implements custom managed Pool plumber APIs. pool consists Plumber struct contain host, port, child process. Deadpool spawns new connection pool, thus spawns new plumber API. done using Command::new() create detached child process. random port generated, checked, assigned plumber API. process started calling R -e \"plumber::plumb('{filepath}')$run(host = '{host}', port = {port})\" via Command. means R must path multiple installs R, whichever one path used. prevent plumber APIs spawned frequently kept alive duration defined max_age. connection can unused duration. exceeds age without used, Deadpool prune connection terminate process. check happens separate thread occurring every check_unused seconds.","code":""},{"path":"/index.html","id":"benchmarks-with-drill","dir":"","previous_headings":"","what":"Benchmarks with drill","title":"Redirects Your Plumbing For You","text":"Simple benchmarks using drill can found inst/bench-sleep-plumber.yml bench-sleep-valve.yml. bench mark calls /sleep endpoint sleeps 500ms 100 times 5 concurrent threads. alone can illustrate much can speed single plumber API’s response time valve. Plumber’s benchmark: Valve’s benchmark:","code":"Time taken for tests      50.7 seconds Total requests            100 Successful requests       100 Failed requests           0 Requests per second       1.97 [#/sec] Median time per request   2540ms Average time per request  2482ms Sample standard deviation 272ms 99.0'th percentile        2556ms 99.5'th percentile        2556ms 99.9'th percentile        2556ms Time taken for tests      10.2 seconds Total requests            100 Successful requests       100 Failed requests           0 Requests per second       9.78 [#/sec] Median time per request   510ms Average time per request  510ms Sample standard deviation 2ms 99.0'th percentile        516ms 99.5'th percentile        518ms 99.9'th percentile        518ms"},{"path":"/index.html","id":"with-all-that-said","dir":"","previous_headings":"Benchmarks with drill","what":"With all that said….","title":"Redirects Your Plumbing For You","text":"valve best suited light medium sized work loads. background plumber API hold copy R objects. serving machine learning model GB big, model copied thread can quickly bloat ram. smart! massive objects R session, try reduce clutter thin .","code":""},{"path":"/reference/valve_run.html","id":null,"dir":"Reference","previous_headings":"","what":"Start a valve App — valve_run","title":"Start a valve App — valve_run","text":"Run plumber API parallel using valve. Plumber APIs spawned n_threads asynchronous threads random ports. Incoming requests handled single port redirected plumber APIs simple round-robin fashion.","code":""},{"path":"/reference/valve_run.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Start a valve App — valve_run","text":"","code":"valve_run(   filepath = \"plumber.R\",   host = \"127.0.0.1\",   port = 3000,   n_max = 3,   workers = n_max,   check_unused = 10,   max_age = 300 )"},{"path":"/reference/valve_run.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Start a valve App — valve_run","text":"filepath default \"plumber.R\". path Plumber API. Provided file argument plumber::plumb(). host default \"127.0.0.1\". host valve app Plumber APIs. port default 3000. port host valve app . n_max default 3. maximum number Plumber APIs run parallel. workers default n_max. number worker threads valve app execute requests. number typically mimic n_max. check_unused default 10. time interval, seconds, check unused connections. max_age default 300 (five minutes). Specifies long connection can go unused without terminated. connection reaches age terminated next pool check (interval determined check_unused),","code":""},{"path":"/reference/valve_run.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Start a valve App — valve_run","text":"","code":"if (interactive()) {   plumber_api_path <- system.file(\"plumber.R\", package = \"valve\")   valve_run(plumber_api_path) }"},{"path":"/reference/valve_write_vetiver.html","id":null,"dir":"Reference","previous_headings":"","what":"Write a Dockerfile for vetiver using valve — valve_write_vetiver","title":"Write a Dockerfile for vetiver using valve — valve_write_vetiver","text":"Valve powered vetiver Dockerfile run prediction endpoints concurrently.","code":""},{"path":"/reference/valve_write_vetiver.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write a Dockerfile for vetiver using valve — valve_write_vetiver","text":"","code":"valve_write_vetiver(   vetiver_model,   plumber_file = \"plumber.R\",   path = \".\",   port = 8000,   vetiver_args = list(),   workers = NULL,   n_max = NULL,   check_unused = NULL,   max_age = NULL )"},{"path":"/reference/valve_write_vetiver.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write a Dockerfile for vetiver using valve — valve_write_vetiver","text":"vetiver_model deployable vetiver_model() object plumber_file path Plumber file, created via vetiver_write_plumber(). Defaults plumber.R working directory. path path write Dockerfile lockfile, capturing model's package dependencies. Defaults working directory. port server port listening: number 8080 expression like '.numeric(Sys.getenv(\"PORT\"))' port injected environment variable. vetiver_args additional arguments passed vetiver::vetiver_write_docker() key-value pairs list object.","code":""},{"path":"/reference/valve_write_vetiver.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write a Dockerfile for vetiver using valve — valve_write_vetiver","text":"content Dockerfile, invisibly.","code":""},{"path":"/reference/valve_write_vetiver.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Write a Dockerfile for vetiver using valve — valve_write_vetiver","text":"function modification vetiver::vetiver_write_docker(). modifies created Dockerfile install Valve, changes ENTRYPOINT use Valve executable instead single plumber API via R command.","code":""}]
