[{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Josiah Parry. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Parry J (2023). valve: Redirects Plumbing . R package version 0.0.0.9000, https://github.com/JosiahParry/valve.","code":"@Manual{,   title = {valve: Redirects Your Plumbing For You},   author = {Josiah Parry},   year = {2023},   note = {R package version 0.0.0.9000},   url = {https://github.com/JosiahParry/valve}, }"},{"path":"/index.html","id":"valve","dir":"","previous_headings":"","what":"Redirects Your Plumbing For You","title":"Redirects Your Plumbing For You","text":"Redirects plumbing . valve creates multi-threaded Plumber APIs powered Rust’s tokio axum web frameworks.","code":""},{"path":"/index.html","id":"motivation","dir":"","previous_headings":"","what":"Motivation","title":"Redirects Your Plumbing For You","text":"Plumber R package creates RESTful APIs R functions. limited API single R process thus single thread. Multiple queries executed sequence came . Scaling plumber APIs easy. intention valve able make scaling plumber APIs, thus R , easier. can make R better leveraging Rust’s “fearless concurrency.”","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Redirects Your Plumbing For You","text":"Install R package using {remotes}. Note compile package source require Rust installed. don’t rust installed follow instructions . Rust second easiest programming language install R. also recommend installing development version {rextendr} via pak::pak(\"extendr/rextendr\") provides function rextendr::rust_sitrep() update compatible Rust installation. R package built also includes binary executable inst/valve. ever find needing executable system.file(\"valve\", package = \"valve\") point right ! always version executable R package using. install executable run","code":"remotes::install_github(\"josiahparry/valve\") cargo install --git https://github.com/josiahparry/valve/ --no-default-features"},{"path":"/index.html","id":"creating-the-app","dir":"","previous_headings":"","what":"Creating the app","title":"Redirects Your Plumbing For You","text":"R package exports 1 function: valve_run(). important argument filepath determines Plumber API executed well specifying host port determine app run. Additional configuration can done n_max, workers, check_unused, max_age argument specify app scale. n_max refers maximum number background Plumber APIs spawned whereas workers specifies many main worker threads available handle incoming requests. Generally, number workers equal number plumber APIs since plumber single threaded. Plumber connections automatically spawned, pooled, terminated using deadpool. App connections automatically pooled hyper. Running R session block session. comfortable, recommended install cli can run terminal can call plumber APIs R session.","code":"library(valve) # get included plumber API path plumber_api_path <- system.file(\"plumber.R\", package = \"valve\")  valve_run(plumber_api_path, n_max = 5, workers = 5) #> Docs hosted at <http://127.0.0.1:3000/__docs__/>"},{"path":"/index.html","id":"calling-valve-with-multiple-workers","dir":"","previous_headings":"","what":"Calling valve with multiple workers","title":"Redirects Your Plumbing For You","text":"way valve works accepting requests main port (3000 default) distributing requests round robin plumber APIs spawned random ports. Requests captured axum proxied plumber API process. First ’m going define function call /sleep endpoint. function take two parameters: port duration sleep. port used change valve app single plumber API. Using function ’ll create 5 total R sessions make request sleep 2 seconds. First, ’ll ping main valve app distribute requests round robin. Next, select one available plumber APIs query . Notice performance difference. former worker gets make request approximately amount time. latter wait subsequent step finish next one can occur. ’ve effectively distributed work load.","code":"sleep <- function(port, secs) {   httr2::request(         paste0(\"127.0.0.1:\", port, \"/sleep?zzz=\", secs)     ) |>      httr2::req_perform() |>      httr2::resp_body_string() } library(furrr) plan(multisession, workers = 5) start <- Sys.time() multi_sleep <- future_map(1:5, ~ sleep(3000, 2)) multi_total <- Sys.time() - start start <- Sys.time() single_sleep <- furrr::future_map(1:5, ~ sleep(35219, 2)) single_total <- Sys.time() - start print(paste0(\"Multiple Plumber APIs: \", round(multi_total, 2))) #> [1] \"Multiple Plumber APIs: 2.63\" print(paste0(\"One Plumber API: \", round(single_total, 2))) #> [1] \"One Plumber API: 10.08\""},{"path":"/index.html","id":"benchmarks-with-drill","dir":"","previous_headings":"","what":"Benchmarks with drill","title":"Redirects Your Plumbing For You","text":"Simple benchmarks using drill can found inst/bench-sleep-plumber.yml bench-sleep-valve.yml. bench mark calls /sleep endpoint sleeps 500ms 100 times 5 concurrent threads. alone can illustrate much can speed single plumber API’s response time valve. Plumber’s benchmark: Valve’s benchmark:","code":"Time taken for tests      50.7 seconds Total requests            100 Successful requests       100 Failed requests           0 Requests per second       1.97 [#/sec] Median time per request   2540ms Average time per request  2482ms Sample standard deviation 272ms 99.0'th percentile        2556ms 99.5'th percentile        2556ms 99.9'th percentile        2556ms Time taken for tests      10.2 seconds Total requests            100 Successful requests       100 Failed requests           0 Requests per second       9.78 [#/sec] Median time per request   510ms Average time per request  510ms Sample standard deviation 2ms 99.0'th percentile        516ms 99.5'th percentile        518ms 99.9'th percentile        518ms"},{"path":"/index.html","id":"with-all-that-said","dir":"","previous_headings":"Benchmarks with drill","what":"With all that said….","title":"Redirects Your Plumbing For You","text":"valve best suited light-ish work loads. background plumber API hold copy R objects. serving machine learning model GB big, model copied thread can quickly bloat ram. smart! massive objects R session, try reduce clutter thin .","code":""},{"path":"/reference/valve_run.html","id":null,"dir":"Reference","previous_headings":"","what":"Start a valve App — valve_run","title":"Start a valve App — valve_run","text":"Run plumber API parallel using valve. Plumber APIs spawned n_threads asynchronous threads random ports. Incoming requests handled single port redirected plumber APIs simple round-robin fashion.","code":""},{"path":"/reference/valve_run.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Start a valve App — valve_run","text":"","code":"valve_run(   filepath = \"plumber.R\",   host = \"127.0.0.1\",   port = 3000,   n_max = 3,   workers = n_max,   check_unused = 10,   max_age = 300 )"},{"path":"/reference/valve_run.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Start a valve App — valve_run","text":"filepath default \"plumber.R\". path Plumber API. Provided file argument plumber::plumb(). host default \"127.0.0.1\". host valve app Plumber APIs. port default 3000. port host valve app . n_max default 3. maximum number Plumber APIs run parallel. workers default n_max. number worker threads valve app execute requests. number typically mimic n_max. check_unused default 10. time interval, seconds, check unused connections. max_age default 300 (five minutes). Specifies long connection can go unused without terminated. connection reaches age terminated next pool check (interval determined check_unused),","code":""},{"path":"/reference/valve_run.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Start a valve App — valve_run","text":"","code":"if (interactive()) {   plumber_api_path <- system.file(\"plumber.R\", package = \"valve\")   valve_run(plumber_api_path) }"},{"path":"/reference/valve_write_vetiver.html","id":null,"dir":"Reference","previous_headings":"","what":"Write a Dockerfile for vetiver using valve — valve_write_vetiver","title":"Write a Dockerfile for vetiver using valve — valve_write_vetiver","text":"function modification vetiver::vetiver_write_docker() utilizes valve run model prediction endpoints parallel.","code":""},{"path":"/reference/valve_write_vetiver.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write a Dockerfile for vetiver using valve — valve_write_vetiver","text":"","code":"valve_write_vetiver(   vetiver_model,   plumber_file = \"plumber.R\",   path = \".\",   port = 8000,   vetiver_args = list() )"},{"path":"/reference/valve_write_vetiver.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write a Dockerfile for vetiver using valve — valve_write_vetiver","text":"vetiver_model deployable vetiver_model() object plumber_file path Plumber file, created via vetiver_write_plumber(). Defaults plumber.R working directory. path path write Dockerfile lockfile, capturing model's package dependencies. Defaults working directory. port server port listening: number 8080 expression like '.numeric(Sys.getenv(\"PORT\"))' port injected environment variable. vetiver_args additional arguments passed vetiver::vetiver_write_docker() key-value pairs list object. @returns content Dockerfile, invisibly.","code":""}]
